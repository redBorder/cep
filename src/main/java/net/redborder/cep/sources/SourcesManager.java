package net.redborder.cep.sources;

import com.lmax.disruptor.EventHandler;
import net.redborder.cep.sources.parsers.ParsersManager;
import net.redborder.cep.util.ConfigData;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Map;

/**
 * This class serves as a manager for the different implementations
 * of sources. It is in charge of creating an instance of each of the
 * sources available on the config file, and to add the streams associated
 * with each of the sources.
 *
 * @see Source
 */

public class SourcesManager {
    private static final Logger log = LogManager.getLogger(SourcesManager.class);

    /**
     * This attribute stores a reference to each of the sources present
     * on the config file as an entry on a map. The entry key is the source
     * name as specified on the config file, and the value associated with it
     * is an instance of that Source, that is created with the Java Reflection API,
     * based on the fully qualified class name specified on the config file for
     * that specific source.
     */

    private Map<String, Source> sources = new HashMap<>();

    /**
     * This method creates the source instances as specified on the config file, and stores
     * them on the 'sources' attribute. After that, it gets the list of streams from the
     * config file and tells each source which streams are going to consume their messages.
     * Finally, it starts each of the sources instances.
     *
     * @param parsersManager A ParsersManager object that will server parsers to the sources instances
     * @param eventHandler   An EventHandler object that will receive messages generated by the sources
     */

    public SourcesManager(ParsersManager parsersManager, EventHandler eventHandler) {
        // For each sources specified on the config file...
        for (Map<String, Object> sourceEntry : ConfigData.getSources()) {
            // Get its name, class and properties
            String sourceName = (String) sourceEntry.get("name");
            String sourceNameClass = (String) sourceEntry.get("class");
            Map<String, Object> properties = (Map<String, Object>) sourceEntry.get("properties");

            try {
                // Get the class from the full qualified class name and instanciate it
                Class sourceClass = Class.forName(sourceNameClass);
                Constructor<Source> constructor = sourceClass.getConstructor(ParsersManager.class, EventHandler.class, Map.class);
                Source source = constructor.newInstance(new Object[]{parsersManager, eventHandler, properties});
                sources.put(sourceName, source);
            } catch (ClassNotFoundException e) {
                log.error("Couldn't find the class associated with the source " + sourceNameClass);
            } catch (NoSuchMethodException | InstantiationException | InvocationTargetException | IllegalAccessException e) {
                log.error("Couldn't create the instance associated with the source " + sourceNameClass, e);
            }
        }

        // For each stream specified on the config file, add it to the
        // set of sources that will produce messages to it.
        for (String streamName : ConfigData.getStreams()) {
            String sourceName = ConfigData.getSource(streamName);
            Source source = sources.get(sourceName);
            if (source != null) {
                source.addStreams(streamName);
            }
        }

        // Start all the sources
        for (Source source : sources.values()) {
            if (source != null) {
                source.start();
            }
        }
    }

    /**
     * Sends a shutdown signal to all the sources instanciated, so they
     * can close connections or release resources.
     */

    public void shutdown() {
        for (Source source : sources.values()) {
            source.shutdown();
        }
    }
}


